{"version":3,"file":"autocompleteInput.js","sourceRoot":"","sources":["../../../../src/autocomplete/autocompleteInput.tsx"],"names":[],"mappings":"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","sourcesContent":["import { equals } from '@everlutionsk/helpers';\nimport { constants, useDelayedTrue, useLatestNonNilValue } from '@everlutionsk/ui';\nimport { Autocomplete, FilterOptionsState, TextField, TextFieldProps } from '@mui/material';\nimport React, { FocusEvent, ReactNode, useMemo, useRef, useState } from 'react';\nimport { AutocompleteOption, LoadingSpinner, mergeOptions, normalizeLabel } from './common';\n\nexport interface AutocompleteInputProps<Value, AllowCustom extends boolean | undefined> {\n  /**\n   * The label content.\n   */\n  readonly label?: ReactNode;\n\n  /**\n   * Available options for suggestion list.\n   */\n  readonly options: Array<AutocompleteOption<Value, AllowCustom>> | undefined;\n\n  /**\n   * Currently selected option.\n   */\n  readonly selected: AutocompleteOption<Value, AllowCustom> | undefined;\n\n  /**\n   * Called when user selects/removes option from suggestions list.\n   */\n  readonly onSelect: (option: AutocompleteOption<Value, AllowCustom> | undefined) => void;\n\n  /**\n   * Debounced callback which will be triggered when search term changes.\n   */\n  readonly onTermChange?: (term: string) => void;\n\n  /**\n   * Allows user to use custom text when provided options are not enough.\n   *\n   * When set to TRUE, selected option may have no value, only label.\n   */\n  readonly allowCustom?: AllowCustom;\n\n  /**\n   * Renders error message when provided.\n   */\n  readonly error?: string;\n\n  /**\n   * If `true`, the `input` element will be focused during the first mount.\n   */\n  readonly autoFocus?: boolean;\n\n  readonly onBlur?: (event: FocusEvent<HTMLDivElement>) => void;\n  readonly placeholder?: string;\n  readonly disabled?: boolean;\n  readonly TextFieldProps?: TextFieldProps;\n  readonly filterOptions?: (\n    options: Array<AutocompleteOption<Value, AllowCustom>>,\n    state: FilterOptionsState<AutocompleteOption<Value, AllowCustom>>\n  ) => Array<AutocompleteOption<Value, AllowCustom>>;\n}\n\n/**\n * Autocomplete input.\n *\n * To use it with Formik, please use AutocompleteField.\n */\nexport function AutocompleteInput<Value, AllowCustom extends boolean | undefined = undefined>(\n  props: AutocompleteInputProps<Value, AllowCustom>\n) {\n  const [term, setTerm] = useState('');\n  const [hasFocus, setFocusState] = useState(false);\n  const [serveFromCache, setServeFromCache] = useState(false);\n  const termDebounceTimer = useRef<any | undefined>();\n\n  const cache = useRef(\n    new Map<string, Array<AutocompleteOption<Value, AllowCustom>> | undefined>()\n  );\n\n  const rawOptions = useLatestNonNilValue(serveFromCache ? cache.current.get(term) : props.options);\n  const options = useMemo(\n    () =>\n      mergeOptions(rawOptions ?? [], props.selected?.value !== undefined ? [props.selected] : []),\n    [rawOptions, props.selected]\n  );\n\n  if (props.options != null) {\n    cache.current.set(term, props.options);\n  }\n\n  const showLoadingSpinner = useDelayedTrue(\n    hasFocus && props.options == null,\n    constants.loadingDelay\n  );\n  const showLoadingMsg = showLoadingSpinner && !props.allowCustom;\n\n  // If there are no options and the input field is empty,\n  // we will temporarily switch to `freeSolo` mode to avoid \"No options\" message.\n  const freeSolo = props.allowCustom || (term.trim().length === 0 && options.length === 0);\n\n  return (\n    <Autocomplete\n      options={options}\n      loading={showLoadingMsg}\n      onChange={(event, _, reason, details) => {\n        if (reason === 'removeOption' || reason === 'clear') {\n          props.onSelect(undefined);\n          setTerm('');\n        }\n\n        const option: AutocompleteOption<Value, AllowCustom> | string | undefined =\n          details?.option as any;\n        if (option == null) return;\n\n        if (reason === 'createOption' || reason === 'selectOption') {\n          if (typeof option === 'string') {\n            const normalizedOptionLabel = normalizeLabel(option);\n\n            const similar = options.find(\n              ({ label }) => normalizeLabel(label) === normalizedOptionLabel\n            );\n            if (similar) {\n              props.onSelect(similar);\n            } else {\n              props.onSelect({ label: option, value: undefined as any });\n            }\n          } else {\n            props.onSelect(option);\n          }\n\n          // Clear the term.\n          //\n          // To keep the value in input field, consumer\n          // needs to set the `props.value` on each change.\n          setTerm('');\n        }\n      }}\n      onFocus={() => setFocusState(true)}\n      onBlur={event => {\n        cache.current.clear();\n        setFocusState(false);\n\n        if (props.allowCustom) {\n          const normalizedTerm = normalizeLabel(term);\n\n          if (normalizedTerm === '') {\n            props.onSelect(undefined);\n          } else {\n            const similar = options.find(({ label }) => normalizeLabel(label) === normalizedTerm);\n\n            if (similar) {\n              props.onSelect(similar);\n              setTerm(similar.label);\n            } else {\n              props.onSelect({ label: term, value: undefined as any });\n            }\n          }\n        }\n\n        props.onBlur?.(event);\n      }}\n      inputValue={term}\n      value={props.selected ?? null}\n      freeSolo={freeSolo}\n      disabled={props.disabled}\n      onInputChange={(_, value, reason) => {\n        setServeFromCache(true);\n        setTerm(value);\n\n        clearTimeout(termDebounceTimer.current);\n        if (reason === 'input' || value === '') {\n          termDebounceTimer.current = setTimeout(() => {\n            props.onTermChange?.(value);\n            setServeFromCache(false);\n          }, constants.searchDebounce);\n        }\n      }}\n      isOptionEqualToValue={(option, value) =>\n        equals(option.value, value.value) || option.label.trim() === value.label.trim()\n      }\n      getOptionLabel={option => (typeof option === 'string' ? option : option?.label ?? '')}\n      renderOption={(props, option) => {\n        if (option == null) return <li {...props}></li>;\n        return <li {...props}>{option.node ?? option.label}</li>;\n      }}\n      filterOptions={props.filterOptions}\n      renderInput={params => (\n        <TextField\n          {...params}\n          type=\"text\"\n          label={props.label}\n          autoFocus={props.autoFocus}\n          error={props.error != null}\n          helperText={props.error}\n          InputProps={{\n            ...params.InputProps,\n            endAdornment: showLoadingSpinner ? <LoadingSpinner /> : params.InputProps.endAdornment\n          }}\n          placeholder={props.placeholder}\n          {...props.TextFieldProps}\n        />\n      )}\n    />\n  );\n}\n"]}